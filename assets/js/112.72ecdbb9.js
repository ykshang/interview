(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{568:function(v,_,t){"use strict";t.r(_);var s=t(3),o=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"计算属性和监听属性的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算属性和监听属性的区别"}},[v._v("#")]),v._v(" 计算属性和监听属性的区别")]),v._v(" "),_("p",[_("strong",[v._v("计算属性是根据现有的数据计算出一个新的值，并将该值缓存起来，只有相关的依赖数据发生变化时，才会重新计算")]),v._v("。计算属性是基于其依赖进行缓存的，只有在依赖的值发生变化时，才会重新计算，当依赖的值没有变化时，会直接返回缓存的结果。所以，计算属性适合用于复杂的逻辑和需要进行缓存的计算。")]),v._v(" "),_("p",[_("strong",[v._v("监听属性是当某个值发生变化时，立即执行指定的函数或表达式")]),v._v("。监听属性通过 "),_("code",[v._v("watch")]),v._v(" 选项来设置，它可以监控一个或多个数据的变化，可以通过深度监听、立即执行以及延时执行等方式来满足不同的需求。所以，监听属性适合用于对数据的变化进行操作或处理副作用。")]),v._v(" "),_("p",[v._v("简而言之，"),_("strong",[v._v("计算属性适用于计算和缓存结果，监听属性适用于对数据变化的实时响应和执行相应处理函数。")])]),v._v(" "),_("p",[_("strong",[v._v("何时使用computed属性")]),v._v("：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("当你需要在模板中使用一个根据其他数据计算得出的值时；")])]),v._v(" "),_("li",[_("p",[v._v("当需要对一个或多个数据进行计算、处理、过滤或格式化时；")])]),v._v(" "),_("li",[_("p",[v._v("当计算结果被多次使用，并且不希望每次都重新计算；")])]),v._v(" "),_("li",[_("p",[v._v("当计算结果依赖的数据发生变化时，希望自动更新计算结果。")])])]),v._v(" "),_("p",[_("strong",[v._v("何时使用watch属性")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("当你需要在数据发生变化时触发某个函数或表达式，或者需要对数据进行复杂的处理或操作时，应该使用监听属性；")]),v._v(" "),_("li",[v._v("当需要监听一个特定的数据变化，并在变化发生时执行一些操作；")]),v._v(" "),_("li",[v._v("当需要在数据变化时进行一些副作用操作，比如发起异步请求、处理复杂的逻辑、更新其他依赖的数据等。")])]),v._v(" "),_("p",[v._v("需要注意的是，computed属性和watch属性虽然在功能上有重叠，但在使用时要根据具体的场景和需求选择合适的方式。在数据量大或计算逻辑复杂的情况下，computed属性更具优势；而对于需要监听特定数据变化并做出响应的情况，使用watch属性更为合适。")]),v._v(" "),_("p",[v._v("根据具体需求选择合适的方式可以提高程序的性能和可维护性。")])])}),[],!1,null,null,null);_.default=o.exports}}]);