(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{487:function(t,v,s){"use strict";s.r(v);var _=s(3),r=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"对象的继承"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对象的继承"}},[t._v("#")]),t._v(" 对象的继承")]),t._v(" "),v("ol",[v("li",[v("a",{attrs:{href:"./10"}},[v("strong",[t._v("原型链继承")])]),t._v(" ：通过将子对象的原型指向父对象，从而继承父对象的属性和方法。这是 JavaScript 中最基本的继承方式。但是它有一些限制，例如所有子对象都共享父对象的属性，不能向父对象的构造函数传递参数等。")]),t._v(" "),v("li",[v("strong",[t._v("构造函数继承")]),t._v("：通过在子对象的构造函数中调用父对象的构造函数，从而继承父对象的属性。这种方式可以解决原型链继承的一些问题，但是它没有继承父对象的原型链上的方法。")]),t._v(" "),v("li",[v("strong",[t._v("组合继承")]),t._v("：结合了原型链继承和构造函数继承，通过调用父对象的构造函数来继承属性，同时将子对象的原型指向父对象，从而继承方法。这是 JavaScript 中最常用的继承方式。")]),t._v(" "),v("li",[v("strong",[t._v("原型式继承")]),t._v("：通过创建一个临时的构造函数，并将父对象作为这个构造函数的原型，从而实现继承。这种方式可以基于已有的对象创建新的对象，但是也会共享父对象的属性。")]),t._v(" "),v("li",[v("strong",[t._v("寄生式继承")]),t._v("：通过创建一个封装继承过程的函数，并在其中创建和返回一个新的对象，从而实现继承。这种方式类似于原型式继承，但是可以在封装函数中添加一些额外的属性和方法。")]),t._v(" "),v("li",[v("strong",[t._v("ES6 类继承")]),t._v("：在 ECMAScript 6 中，引入了 "),v("code",[t._v("class")]),t._v(" 关键字和 "),v("code",[t._v("extends")]),t._v(" 关键字，使得类和继承变得更加简洁和直观。可以通过 "),v("code",[t._v("extends")]),t._v(" 关键字来实现类之间的继承。")])])])}),[],!1,null,null,null);v.default=r.exports}}]);