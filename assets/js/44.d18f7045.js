(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{496:function(t,s,i){"use strict";i.r(s);var _=i(3),a=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"this的指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this的指向"}},[t._v("#")]),t._v(" this的指向")]),t._v(" "),s("h2",{attrs:{id:"_1-全局作用域中的this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-全局作用域中的this"}},[t._v("#")]),t._v(" 1. 全局作用域中的this")]),t._v(" "),s("p",[t._v("在全局作用域中，this引用全局对象：")]),t._v(" "),s("ul",[s("li",[t._v("浏览器环境中是window对象")]),t._v(" "),s("li",[t._v("Node.js环境中是global对象")])]),t._v(" "),s("h2",{attrs:{id:"_2-函数中的this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-函数中的this"}},[t._v("#")]),t._v(" 2. 函数中的this")]),t._v(" "),s("p",[t._v("在函数中，this的值取决于函数是如何被调用的：")]),t._v(" "),s("ul",[s("li",[t._v("如果函数作为普通函数（"),s("code",[t._v("fun()")]),t._v("）调用（不是作为对象的方法或构造函数），this指向全局对象（非严格模式）或undefined（严格模式）。")]),t._v(" "),s("li",[t._v("如果函数作为对象的方法（"),s("code",[t._v("obj.fun()")]),t._v("）调用，this指向该对象。")]),t._v(" "),s("li",[t._v("如果函数作为构造函数调用（通过new关键字"),s("code",[t._v("xxx = new Obj()")]),t._v("），this指向由构造函数创建的新对象。")]),t._v(" "),s("li",[t._v("如果函数使用call()、apply()或bind()方法改变内部值域，this指向作为参数传递的对象。")])]),t._v(" "),s("h2",{attrs:{id:"_3-箭头函数中的this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-箭头函数中的this"}},[t._v("#")]),t._v(" 3. 箭头函数中的this")]),t._v(" "),s("p",[t._v("箭头函数没有自己的this，它会继承当前上下文中的this值。这意味着在箭头函数中，this指向定义时的外层作用域中的this。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),s("p",[t._v("需要注意的是，为了避免this的指向问题，可以使用bind()、call()、apply()等方法显式地设置函数的this值。另外，在ES6中，可以使用箭头函数来避免this指向问题。")])])])}),[],!1,null,null,null);s.default=a.exports}}]);