# 前端路由

## 什么是前端路由？

路由的概念来源于服务端，在服务端中路由描述的是 URL 与处理函数之间的映射关系。

在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。

## 如何实现前端路由？

要实现前端路由，需要解决两个核心问题：

1. 如何改变 URL 却不引起页面刷新？
2. 如何检测 URL 变化了？

## 三种主要的路由模式

下面分别使用 **Hash**，**History（HTML5）**， **Abstract（Memory）** 三种实现方式分别介绍

### 1. Hash 哈希模式

核心通过`hashchange` 事件来监听`url`中的`hash`，根据hash查找路由表，拿到相应页面渲染到当前页面

**特点：**

1. **不依赖服务器**：所有工作在前端完成，不依赖服务器配合
2. **URL中带有`#`**：有点不美观
3. **兼容性好**：支持所有浏览器，尤其一些老的浏览器
4. **对SEO不友好**：因为搜索引擎对无法识别#后边的内容，影响页面排名

**参考案例：** [Hash 方式实现前端路由](https://ykshang.github.io/MyStaticDemo/static/%E4%BB%A5hash%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%20.html)

```Vue
<script>
// 定义 Router
class Router {
  constructor() {
    this.routes = {}; // 路由表，存放路由path及callback
  }
  // 给路由绑定对应的默认处理函数
  // 实际上Vue中还会在参数中加入component信息，用于传入对应的组件
  route(path, callback) {
    this.routes[path] = callback;
  }
  // 触发路由变化
  push(path) {
    window.location.hash = "#" + path; // 改变当前的hash值
    this.routes[path] && this.routes[path](); // 执行对应回调函数
  }
  // hash根据哈希值触发对应的页面刷新
  refresh(event) {
    return function () {
      let hash = window.location.hash;
      console.log(event, "检测到", hash);
      if (hash === "#/") {
        // View更新为首页
      } else if (hash === "#/page1") {
        // View更新page1
      } else if (hash === "#/page2") {
        // View更新为page2
      } else {
        // 其他页面
      }
    };
  }
}
// 使用 router
window.miniRouter = new Router();

// 增加监听事件 第一种
// window.addEventListener("load", miniRouter.refresh('load'), false); // 页面加载时触发
// window.addEventListener("hashchange", miniRouter.refresh('hashchange'), false); // hash值变化时触发

// 增加监听事件 第二种
window.onload = miniRouter.refresh("load"); // 页面加载时触发
window.onhashchange = miniRouter.refresh("hashchange"); // hash值变化时触发

// 注册路由
miniRouter.route("/", () => console.log("home page"));
miniRouter.route("/page1", () => console.log("page1"));
miniRouter.route("/page2", () => console.log("page2"));

// 路由跳转
miniRouter.push("/");
// 输出
// home page
// hashchange 检测到 #/
miniRouter.push("/page1"); // page1
// 输出
// page1
// hashchange 检测到 #/page1
miniRouter.push("/page2"); // page2
// 输出
// page2
// hashchange 检测到 #/page2
</script>
<!----也可以通过以下方式去触发测试---->
<template>
  <a href="#/">home page</a> |
  <a href="#/page1">page1</a> |
  <a href="#/page2">page2</a>
  <component :is="currentView" />
</template>

```

### 2. History（HTML5）模式

history 模式核心依赖 `History Api`，该Api 提供了丰富的 router 相关属性

先了解一个几个相关的 api:

``` js
window.history.go // 可以跳转到浏览器会话历史中的指定的某一个记录页
window.history.forward // 指向浏览器会话历史中的下一页，跟浏览器的前进按钮相同
window.history.back // 返回浏览器会话历史中的上一页，跟浏览器的回退按钮功能相同
window.history.pushState // 可以将给定的数据压入到浏览器会话历史栈中
window.history.replaceState // 将当前的会话页面的url替换成指定的数据
window.addEventListener("popstate", (e) => {}); // 当 history 发生变化时触发
```

**特点：**

1. **兼容性有限制**：依赖`HTML5`提供的`history api`，所以意味着很多老浏览器不支持
2. **URL不含`#`**: 看起来美观，同时意味着一些限制
2. **SEO友好**：URL不含`#`，对搜索引擎SEO优化友好
3. **需要服务器配置支持**：由于URL不含`#`，在页面刷新或者初次加载时，服务器会将其识别为静态资源，去请求对应的资源。因此需要服务器配置路由表，根据对应的路由返回对应的归属页面。

**参考案例：** [History 方式实现前端路由](https://ykshang.github.io/MyStaticDemo/static/%E4%BB%A5history%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1.html) 

history api 需要服务器的支持，可以将代码在 **VsCode** 的 **LiveServer** 插件中运行

```Vue
<script>
  // 定义 Router对象 class方式 需要浏览器支持ES6
  // 定义 Router
  class Router {
    constructor() {
      this.routes = {};
      this.listerPopState();
    }
    // 初始化
    init(path) {
      window.history.replaceState({ path: path }, null, path);
      this.routes[path] && this.routes[path]();
    }
    // 路由注册，绑定路由对应的处理函数
    // 实际上Vue中还会在参数中加入component信息，用于传入对应的组件
    route(path, callback) {
      this.routes[path] = callback;
      console.log('注册路由成功：', path)
    }
    // 添加历史记录
    push(path) {
      window.history.pushState({ path: path }, null, path);
    }
    // 监控路由变化
    listerPopState() {
      // 路由变化时会触发popstate事件
      window.addEventListener("popstate", (e) => {
        console.log(e);
        const path = e.state && e.state.path;
        this.routers[path] && this.routers[path]();
      });
    }
  }
  // 使用 Router
  window.miniRouter = new Router();
  // 使用 实例化 router
  window.miniRouter = new Router();

  // 注册路由
  miniRouter.route("./", () => console.log("当前页面：Home Page"));
  miniRouter.route("./Page1", () => console.log("当前页面：Page1"));
  miniRouter.route("./Page2", () => console.log("当前页面：Page2"));

  // 路由跳转
  let clickBtn = function (path) {
    miniRouter.push(path);
  };
</script>
```

### 2. Abstract（Memory）内存模式



## 实际应用

### 1. vue 中 hash 实现简单路由

```VUE
<script setup>
import { ref, computed } from 'vue'
import Home from './Home.vue'
import About from './About.vue'
import NotFound from './NotFound.vue'
const routes = {
  '/': Home,
  '/about': About
}
const currentPath = ref(window.location.hash)
window.addEventListener('hashchange', () => {
  currentPath.value = window.location.hash
})
const currentView = computed(() => {
  return routes[currentPath.value.slice(1) || '/'] || NotFound
})
</script>
<template>
  <a href="#/">Home</a> |
  <a href="#/about">About</a> |
  <a href="#/non-existent-path">Broken Link</a>
  <component :is="currentView" />
</template>
```
