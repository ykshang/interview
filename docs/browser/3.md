# 前端路由

## 什么是前端路由？

路由的概念来源于服务端，在服务端中路由描述的是 URL 与处理函数之间的映射关系。

在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。

## 如何实现前端路由？

要实现前端路由，需要解决两个核心问题：

1. 如何改变 URL 却不引起页面刷新？
2. 如何检测 URL 变化了？

下面分别使用 hash 和 history 两种实现方式回答上面的两个核心问题。

### hash 模式

核心通过监听`url`中的`hash`来进行路由跳转

**参考案例：** [Hash方式实现前端路由](https://ykshang.github.io/MyStaticDemo/static/%E4%BB%A5hash%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%20.html)
``` Vue
<script>
// 定义 Router
class Router {
  constructor() {
    this.routes = {}; // 路由表，存放路由path及callback
  }
  // 给路由绑定对应的默认处理函数
  route(path, callback) {
    this.routes[path] = callback;
  }
  // 触发路由变化
  push(path) {
    window.location.hash = "#" + path; // 改变当前的hash值
    this.routes[path] && this.routes[path](); // 执行对应回调函数
  }
  // hash根据哈希值触发对应的页面刷新
  refresh(event) {
    return function () {
      let hash = window.location.hash;
      console.log(event, "检测到", hash);
      if (hash === "#/") {
        // 更新为首页
      } else if (hash === "#/page1") {
        // 更新页面内容为page1
      } else if (hash === "#/page2") {
        // 更新页面内容为page2
      } else {
        // 其他页面
      }
    };
  }
}
// 使用 router
window.miniRouter = new Router();

// 增加监听事件 第一种
// window.addEventListener("load", miniRouter.refresh('load'), false); // 页面加载时触发
// window.addEventListener("hashchange", miniRouter.refresh('hashchange'), false); // hash值变化时触发

// 增加监听事件 第二种
window.onload = miniRouter.refresh("load"); // 页面加载时触发
window.onhashchange = miniRouter.refresh("hashchange"); // hash值变化时触发

// 注册路由
miniRouter.route("/", () => console.log("home page"));
miniRouter.route("/page1", () => console.log("page1"));
miniRouter.route("/page2", () => console.log("page2"));

// 路由跳转
miniRouter.push("/");
// 输出
// home page 
// hashchange 检测到 #/
miniRouter.push("/page1"); // page1
// 输出
// page1
// hashchange 检测到 #/page1
miniRouter.push("/page2"); // page2
// 输出
// page2
// hashchange 检测到 #/page2
</script>
<!----也可以通过以下方式去触发测试---->
<template>
  <a href="#/">home page</a> |
  <a href="#/page1">page1</a> |
  <a href="#/page2">page2</a>
  <component :is="currentView" />
</template>

```

### history 模式

history 模式核心借用 `HTML5 history api`，api 提供了丰富的 router 相关属性

先了解一个几个相关的 api:

`history.pushState()` 浏览器历史纪录添加记录

`history.replaceState()` 修改浏览器历史纪录中当前纪录

`history popState事件` 当 history 发生变化时触发

``` javascript
// 定义 Router
class Router {
  constructor() {
    this.routes = {};
    this.listerPopState();
  }
  // 初始化
  init(path) {
    history.replaceState({ path: path }, null, path);
    this.routes[path] && this.routes[path]();
  }
  // 路由注册，绑定路由对应的处理函数
  route(path, callback) {
    this.routes[path] = callback;
  }
  // 添加历史记录
  push(path) {
    history.pushState({ path: path }, null, path);
    this.routes[path] && this.routes[path]();
  }
  // 监控路由变化
  listerPopState() {
    // 路由变化时会触发popstate事件
    window.addEventListener("popstate", (e) => {
      const path = e.state && e.state.path;
      this.routers[path] && this.routers[path]();
    });
  }
}

// 使用 Router
window.miniRouter = new Router();
// 注册路由
miniRouter.route("/", () => console.log("page1"));
miniRouter.route("/page2", () => console.log("page2"));

// 跳转
miniRouter.push("/page2"); // page2
```

## 实际应用

### 1. vue中hash实现简单路由

``` VUE
<script setup>
import { ref, computed } from 'vue'
import Home from './Home.vue'
import About from './About.vue'
import NotFound from './NotFound.vue'
const routes = {
  '/': Home,
  '/about': About
}
const currentPath = ref(window.location.hash)
window.addEventListener('hashchange', () => {
  currentPath.value = window.location.hash
})
const currentView = computed(() => {
  return routes[currentPath.value.slice(1) || '/'] || NotFound
})
</script>
<template>
  <a href="#/">Home</a> |
  <a href="#/about">About</a> |
  <a href="#/non-existent-path">Broken Link</a>
  <component :is="currentView" />
</template>
````
