# 前端路由

## 1. 什么是前端路由？

路由的概念来源于服务端，在服务端中路由描述的是 URL 与处理函数之间的映射关系。在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI View（视图）之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。在单页应用中，页面不会因为路径的改变而重新加载，而是通过`前端路由`来`动态更新视图`。这种机制依赖于`浏览器的历史 API（History API）`和`事件监听`，使得用户在切换页面时，不会触发页面的重新加载，从而实现快速无刷新切换。

::: tip 前端路由的核心
核心组成部分主要分为以下三部分：

- 路由器（Router）：即路由表，负责管理路由和视图的匹配。
- 路由（Route）：定义了路径与处理函数的映射关系。
- 视图（View）：与路由对应的页面内容。
- 路由状态信息管理：用于管理和缓存历史信息，适配浏览器的前进后退等操作

:::

::: tip 如何实现前端路由？
要实现前端路由，需要解决两个核心问题：

1. 如何改变 URL 却不引起页面刷新？
2. 如何检测 URL 变化了？
   :::

## 2. 前端路由的工作原理

前端路由的工作原理主要依赖于浏览器提供的 History API 和事件监听机制。当用户在应用中导航到不同的 URL 时，前端路由会拦截这些导航事件，并根据定义的路由规则来更新页面内容，而不是重新加载整个页面。

### 2.1 路由的匹配机制

前端路由的核心是路由匹配机制，它负责将 URL 路径与路由规则进行匹配，然后根据匹配结果执行相应的处理函数。
::: tip 这个过程通常包括以下几个步骤：

1. 解析当前 URL，获取路径信息。
2. 将路径信息与路由规则进行匹配。
3. 如果找到匹配的路由规则，则执行对应的处理函数，更新页面视图。

:::

### 2.2 事件监听

前端路由通过监听浏览器的事件来实现路由的切换。以下是几个主要的事件：

::: tip 以下是几个主要的事件：

- **popstate 事件：** 当用户点击浏览器的前进、后退按钮或某个按钮、链接来触发 URL 的变化时，会触发 <Codes>popstate</Codes> 事件。
  - History 路由监听这个事件来更新页面视图。
- **load 事件：** 当用户通过特定的 URL 打来网页或者刷新网页时，会触发 load 事件。
  - Hash 路由一般会根据路由规则找到对应的页面来更新视图
  - History 路由下，服务器一般会根据路由返回对应的归属页面，对应页面内的 History 路由根据路由规则找到对应的视图加载页面
- **hashchange 事件：** 当页面点击链接、按钮或者浏览器的前进、后退按钮时。
  - Hash 路由一般会根据路由规则找到对应的页面来更新视图

:::

## 3. 三种主要的路由模式

| 路由模式              | 优点                                                         | 缺点                                                           | 适用场景                                                                |
| --------------------- | ------------------------------------------------------------ | -------------------------------------------------------------- | ----------------------------------------------------------------------- |
| Hash                  | 兼容性好 <br/>无需服务器配置 <br/>不会刷新页面               | SEO 友好性较差 <br/>URL 不美观 <br/>需要广泛浏览器兼容性的项目 | 托管在静态服务器上的项目<br/>对 SEO 要求不高的内部工具或管理后台        |
| History<br/>(Html 5)  | URL 更加美观<br>更好的 SEO 支持<br/>与浏览器历史管理无缝集成 | 需要服务器配置<br/>兼容性有限<br/>                             | 对外公开的网站或应用<br/>需要美观 URL 的项目<br/>已经配置了服务器的项目 |
| Memory<br/>(Abstract) | 灵活性高<br/>不需要服务器配置                                | 无法利用浏览器的历史管理<br/>不适合普通 Web 应用               | 服务器端渲染（SSR）<br/>单元测试<br/>桌面应用或 Electron 应用           |

下面分别对 **Hash**，**History（HTML5）**， **Abstract（Memory）** 三种实现方式分别介绍

### 3.1 Hash 哈希模式

核心通过`hashchange` 事件来监听`url`中的`hash`，根据 hash 查找路由表，拿到相应页面渲染到当前页面

::: tip 特点：

1. **不依赖服务器**：所有工作在前端完成，不依赖服务器配合
2. **URL 中带有`#`**：有点不美观
3. **兼容性好**：支持所有浏览器，尤其一些老的浏览器，**最低为 IE8**
4. **对 SEO 不友好**：因为搜索引擎对无法识别#后边的内容，影响页面排名

:::

**参考案例：** [Hash 方式实现前端路由](https://ykshang.github.io/MyStaticDemo/static/%E4%BB%A5hash%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%20.html)

```Vue
<script>
// 定义 Router
class Router {
  constructor() {
    this.routes = {}; // 路由表，存放路由path及callback
  }
  // 给路由绑定对应的默认处理函数
  // 实际上Vue中还会在参数中加入component信息，用于传入对应的组件
  route(path, callback) {
    this.routes[path] = callback;
  }
  // 触发路由变化
  push(path) {
    window.location.hash = "#" + path; // 改变当前的hash值
    this.routes[path] && this.routes[path](); // 执行对应回调函数
  }
  // hash根据哈希值触发对应的页面刷新
  refresh(event) {
    return function () {
      let hash = window.location.hash;
      console.log(event, "检测到", hash);
      if (hash === "#/") {
        // View更新为首页
      } else if (hash === "#/page1") {
        // View更新page1
      } else if (hash === "#/page2") {
        // View更新为page2
      } else {
        // 其他页面
      }
    };
  }
}
// 使用 router
window.miniRouter = new Router();

// 增加监听事件 第一种
// window.addEventListener("load", miniRouter.refresh('load'), false); // 页面加载时触发
// window.addEventListener("hashchange", miniRouter.refresh('hashchange'), false); // hash值变化时触发

// 增加监听事件 第二种
window.onload = miniRouter.refresh("load"); // 页面加载时触发
window.onhashchange = miniRouter.refresh("hashchange"); // hash值变化时触发

// 注册路由
miniRouter.route("/", () => console.log("home page"));
miniRouter.route("/page1", () => console.log("page1"));
miniRouter.route("/page2", () => console.log("page2"));

// 路由跳转
miniRouter.push("/");
// 输出
// home page
// hashchange 检测到 #/
miniRouter.push("/page1"); // page1
// 输出
// page1
// hashchange 检测到 #/page1
miniRouter.push("/page2"); // page2
// 输出
// page2
// hashchange 检测到 #/page2
</script>
<!----也可以通过以下方式去触发测试---->
<template>
  <a href="#/">home page</a> |
  <a href="#/page1">page1</a> |
  <a href="#/page2">page2</a>
  <component :is="currentView" />
</template>

```

### 3.2 History（HTML5）模式

history 模式核心依赖 `History Api`，该 Api 提供了丰富的 router 相关属性

::: tip 特点：

1. **兼容性有限制**：依赖`HTML5`提供的`history api`，所以意味着很多老浏览器不支持，**最低支持 IE10**
2. **URL 不含`#`**: 看起来美观，同时意味着一些限制
3. **SEO 友好**：URL 不含`#`，对搜索引擎 SEO 优化友好
4. **需要服务器配置支持**：由于 URL 不含`#`，在页面刷新或者初次加载时，服务器会将其识别为对应路径的静态资源，去请求对应的资源。因此需要服务器配置路由表，如果找不到对应资源，就根据对应的路由返回对应的归属页面。也可以使用一些中间件 `connect-history-api-fallback` 在 node 服务中处理。

:::

**了解一个几个相关的 api:**

- `window.history.go()` 可以跳转到浏览器会话历史中的指定的某一个记录页
- `window.history.forward()` 指向浏览器会话历史中的下一页，跟浏览器的前进按钮相同
- `window.history.back()` 返回浏览器会话历史中的上一页，跟浏览器的回退按钮功能相同
- `window.history.pushState()` 可以将给定的数据压入到浏览器会话历史栈中
- `window.history.replaceState()` 将当前的会话页面的 url 替换成指定的数据
- `window.addEventListener("popstate", (e) => {})` 当 history 发生变化时触发

**参考案例：** [History 方式实现前端路由](https://ykshang.github.io/MyStaticDemo/static/%E4%BB%A5history%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1.html)

history api 需要服务器的支持，可以将代码在 **VsCode** 的 **LiveServer** 插件中运行

```Vue
<script>
  // 定义 Router对象 class方式 需要浏览器支持ES6
  // 定义 Router
  class Router {
    constructor() {
      this.routes = {};
      this.listerPopState();
    }
    // 初始化
    init(path) {
      window.history.replaceState({ path: path }, null, path);
      this.routes[path] && this.routes[path]();
    }
    // 路由注册，绑定路由对应的处理函数
    // 实际上Vue中还会在参数中加入component信息，用于传入对应的组件
    route(path, callback) {
      this.routes[path] = callback;
      console.log('注册路由成功：', path)
    }
    // 添加历史记录
    push(path) {
      window.history.pushState({ path: path }, null, path);
    }
    // 监控路由变化
    listerPopState() {
      // 路由变化时会触发popstate事件
      window.addEventListener("popstate", (e) => {
        console.log(e);
        const path = e.state && e.state.path;
        this.routers[path] && this.routers[path]();
      });
    }
  }
  // 使用 Router
  window.miniRouter = new Router();
  // 使用 实例化 router
  window.miniRouter = new Router();

  // 注册路由
  miniRouter.route("./", () => console.log("当前页面：Home Page"));
  miniRouter.route("./Page1", () => console.log("当前页面：Page1"));
  miniRouter.route("./Page2", () => console.log("当前页面：Page2"));

  // 路由跳转
  let clickBtn = function (path) {
    miniRouter.push(path);
  };
</script>
```

### 3.3 Abstract（Memory）内存模式

Memory 模式是一种抽象的路由模式，它不依赖于浏览器的 URL，而是完全在内存中管理路由状态。这种模式通常用于那些不需要浏览器 URL 和前进/后退功能的场景，例如服务器端渲染（SSR）、单元测试、小程序或桌面应用。Memory 模式的核心思想是将路由状态保存在内存中，而不是依赖浏览器的历史记录或 URL。

::: tip 特点：

1. 路由规则和状态信息保存在内存里
2. 依赖 Node.js 环境，不依赖于浏览器
3. 不支持普通 web 应用，适用于服务端渲染、小程序、单元测试、桌面应用等不涉及浏览器和 URl 的景。
4. 不需要服务器配置

:::

## 4. 常见前端路由的实现方式

### 4.1 JavaScript 原生实现

根据前文所述的三种模式，我们可以简单实现一个前端路由

### 4.2 基于 Vue 的路由

Vue.js 提供了官方的路由管理器 Vue Router，它允许你为单页应用定义路由规则，并通过组件来渲染对应的视图。

```vue
<script setup>
import { ref, computed } from "vue";
import Home from "./Home.vue";
import About from "./About.vue";
import NotFound from "./NotFound.vue";
const routes = {
  "/": Home,
  "/about": About,
};
const currentPath = ref(window.location.hash);
window.addEventListener("hashchange", () => {
  currentPath.value = window.location.hash;
});
const currentView = computed(() => {
  return routes[currentPath.value.slice(1) || "/"] || NotFound;
});
</script>
<template>
  <a href="#/">Home</a> | <a href="#/about">About</a> |
  <a href="#/non-existent-path">Broken Link</a>
  <component :is="currentView" />
</template>
```

### 4.3 基于 React 的路由

React 有多个路由库，其中最流行的是 React Router。React Router 为 React 应用提供了路由功能，允许你在应用中设置多个路由，并在用户导航时渲染相应的组件。

```jsx
// React Router 示例
import React from "react";
import { BrowserRouter as Router, Route, Switch } from "react-router-dom";
import Home from "./components/Home";
import About from "./components/About";

const App = () => (
  <Router>
    <Switch>
      <Route exact path="/" component={Home} />
      <Route path="/about" component={About} />
    </Switch>
  </Router>
);

export default App;
```

### 4.4 基于 Angular 的路由

Angular 提供了一个强大的路由模块，它允许你创建单页应用中的多个视图，并且可以嵌套路由。

```jsx
// Angular 路由示例
import { NgModule } from "@angular/core";
import { BrowserModule } from "@angular/platform-browser";
import { RouterModule, Routes } from "@angular/router";
import { HomeComponent } from "./home.component";
import { AboutComponent } from "./about.component";

const routes: Routes = [
  { path: "", component: HomeComponent },
  { path: "about", component: AboutComponent },
];

@NgModule({
  imports: [BrowserModule, RouterModule.forRoot(routes)],
  declarations: [HomeComponent, AboutComponent],
  bootstrap: [HomeComponent],
})
export class AppModule {}
```

## 5. 页面跳转与路由的关联

在单页应用中，页面跳转与路由的关联是实现用户界面动态更新的关键。当用户与应用交互时，例如点击一个链接或按钮，前端路由系统会拦截这些交互事件，根据定义的路由规则来更新页面内容，而不是重新加载整个页面。

### 5.1 页面跳转的触发方式

页面跳转可以由以下几种方式触发：

- 链接点击：用户点击带有 `<a>` 标签的链接。
- 地址栏输入：用户直接在浏览器地址栏输入 URL 或者修改当前的 URL。
- 表单提交：带有 `action` 属性的表单提交。
- JavaScript 代码：通过 JavaScript 封装前端路由组件，使用组件由对外暴露的方法来动态修改 `window.location` 或使用 `history` API。
- 浏览器的前进、后退、刷新按钮：用户直接点击浏览器页面上的前进、后退、刷新按钮

### 5.2 二者的协同工作

前端路由与页面跳转的协同工作主要依赖于以下几个步骤：

1. **页面跳转**：用户通过前文所述方式触发页面跳转。
2. **事件监听**：前端路由系统通过事件检测到页面跳转。
3. **事件拦截**：当这些事件被触发时，前端路由会根据事件来源选择性拦截默认的事件处理行为。（ 例如：阻止链接的默认跳转，否则会触发页面刷新，重新请求服务器，破坏前端路由的管控。）
4. **路径解析**：前端路由解析当前触发事件的路径信息，可能是 hash 值、路径字符串等。
5. **路由匹配**：将解析得到的路径与路由规则进行匹配，找到对应的路由处理函数。
6. **视图更新**：执行路由处理函数，更新页面视图，可能是渲染新的组件或更新现有组件的状态。

## 6. 路由的代码分割

在现代前端框架中，代码分割是优化应用性能的重要手段。它们允许开发者将代码拆分成多个小块，按需加载，从而减少初始加载时间，加快首次渲染速度。

代码分割是将代码分成多个块（chunks），然后按需加载这些块的过程。它通常与懒加载结合使用，以优化应用的加载时间。

代码分割通常是通过构建工具（如 Webpack）来实现的。以下是一个简单的 Webpack 配置示例，演示了如何进行代码分割：

``` js
// Webpack配置文件（webpack.config.js）
module.exports = {
  // 入口文件
  entry: './src/index.js',
  // 输出配置
  output: {
    filename: '[name].bundle.js',
    path: __dirname + '/dist',
    chunkFilename: '[name].bundle.js',
    publicPath: 'dist/'
  },
  // 模块分割配置
  optimization: {
    splitChunks: {
      chunks: 'all'
    }
  },
  // 其他配置...
};
```

在这个配置中，splitChunks 选项用于定义代码分割的行为。设置 chunks: 'all' 意味着对所有模块进行分割，包括异步和非异步模块。

### 6.1 路由的懒加载

路由的懒加载指的是在用户访问到某个路由时，才加载该路由对应的组件代码。这种方式可以减少应用的初始负载，因为不是所有的组件代码都会在开始时加载。

### 6.2 懒加载的常见实现方式

#### 基于 ES6 的原生实现

ES moudles 定义了模块的 <b>导入 Export</b>、<b>导出 Import</b>规范，其中`import().then(()=>{})`是支持<b>异步</b>、<b>动态加载</b>的

#### 基于 Vue 的懒加载

在 Vue 中，可以使用动态 import() 语法来定义路由组件，从而实现懒加载。

```js
const routes = [ { path: '/home', component: () =>
import('./components/Home.vue') }, { path: '/about', component: () =>
import('./components/About.vue') } // 其他路由... ];
```

#### 基于 React 的懒加载

在 React 中，可以使用 React.lazy 和 Suspense 来实现组件的懒加载。

```jsx
import React, { Suspense, lazy } from 'react';
const Home = lazy(() => import('./components/Home'));
const About = lazy(() => import('./components/About'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Home />
      <About />
    </Suspense>
  );
}
```


#### 基于 AngularJs 的懒加载

在 Angular 中，可以在路由配置中使用 loadChildren 属性来实现模块的懒加载。
```jsx

const routes: Routes = [
  { 
    path: 'home', 
    loadChildren: () => import('./home/home.module').then(m => m.HomeModule)
  },
  { 
    path: 'about', 
    loadChildren: () => import('./about/about.module').then(m => m.AboutModule)
  }
  // 其他路由...
];
```

## 7. 路由的懒加载

## 8. 路由的预加载
