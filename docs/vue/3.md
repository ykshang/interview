## 3. 计算属性 computed

模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。所以，对于任何复杂逻辑，你都应当使用计算属性。

### 一般写法

例如：我们可以在代码中使用`this.reversedMessage`，他的值始终取决于`this.message`。

```js
computed: {
  // 计算属性的 getter
  reversedMessage: function () {
    // `this` 指向 vm 实例
    return this.message.split('').reverse().join('')
  }
}
```

### getter和setter

getter和setter 是内置的写法，让我们可以有更加灵活的组织代码：

- getter对应的是`计算属性 computed`一般写法，一般是依赖变量发生变化后，引起计算属性值变化

- setter相当于`监听属性 watch`，对应的计算属性的值被其它代码修改后，返回来，我们可以通过setter来完成一些其他的逻辑，比如修改其他变量的值

``` js
fullName: {
  // getter
  get: function () {
    return this.firstName + ' ' + this.lastName
  },
  // setter
  set: function (newValue) {
    var names = newValue.split(' ')
    this.firstName = names[0]
    this.lastName = names[names.length - 1]
  }
}
```

## 4. 监听属性 watch

虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。

```js
watch: {
  // 如果 `question` 发生改变，这个函数就会运行
  question: function (newQuestion, oldQuestion) {
    this.answer = 'Waiting for you to stop typing...'
    this.debouncedGetAnswer()
  }
},
```

## 5. 计算属性和监听属性的区别

**计算属性是根据现有的数据计算出一个新的值，并将该值缓存起来，只有相关的依赖数据发生变化时，才会重新计算**。计算属性是基于其依赖进行缓存的，只有在依赖的值发生变化时，才会重新计算，当依赖的值没有变化时，会直接返回缓存的结果。所以，计算属性适合用于复杂的逻辑和需要进行缓存的计算。

**监听属性是当某个值发生变化时，立即执行指定的函数或表达式**。监听属性通过 `watch` 选项来设置，它可以监控一个或多个数据的变化，可以通过深度监听、立即执行以及延时执行等方式来满足不同的需求。所以，监听属性适合用于对数据的变化进行操作或处理副作用。

简而言之，**计算属性适用于计算和缓存结果，监听属性适用于对数据变化的实时响应和执行相应处理函数。**

- 当你需要在模板中使用一个根据其他数据计算得出的值时，应该使用计算属性。
- 当你需要在数据发生变化时触发某个函数或表达式，或者需要对数据进行复杂的处理或操作时，应该使用监听属性。

根据具体需求选择合适的方式可以提高程序的性能和可维护性。

## 6. 过滤器 filter

在 Vue 中，过滤器是一种用于数据处理和格式化的功能。它们可以在模板中使用管道符`|`来对数据进行转换。过滤器可以在输出之前对数据进行一系列的处理操作，例如格式化日期、转换大小写等。

```html
<div id="app">
  <p>原始日期：{{ date }}</p>
  <p>格式化后的日期：{{ date | formatDate }}</p>
</div>
```

```js
// 全局
Vue.filter('formatDate', function(value) {
  // 使用 Moment.js 库来格式化日期
  return moment(value).format('YYYY-MM-DD');
});
new Vue({
  el: "#app",
  data: {
    date: "2022-01-01",
  },
});
// 组件内
filters: {
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}
```
## 7. 混入 mixin

混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项：选项、方法、数据等。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。

``` js
// 定义一个混入对象
var myMixin = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log('hello from mixin!')
    }
  }
}

// 定义一个使用混入对象的组件
var Component = Vue.extend({
  mixins: [myMixin]
})

var component = new Component() // => "hello from mixin!"
```

### 优点

1. **代码复用**：通过混入，可以将一些通用的逻辑封装在一个混入对象中，并在需要的组件中引入该混入对象，实现代码的复用。
2. **功能扩展**：混入可以用来扩展组件的功能，比如添加一些`生命周期钩子函数、方法、计算属性`等。当多个组件需要相同的功能时，可以使用混入来统一添加这些逻辑，避免重复编写代码。
3. **组件配置的组合**：通过混入，我们可以将一些组件配置选项合并到组件的配置中，从而实现灵活的配置组合。这对于多个组件需要共享相同的配置选项时非常有用。

### 合并策略

当组件和混入对象含有同名选项时，这些选项会进行“**合并**”。

- **data**：数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先：即**组件data和混入对象的data同名是，以组件data为准**。
- **生命周期钩子**：同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子**之前**调用。即先执行混入对象的同名钩子，后执行组件自身的同名钩子
- 值为对象的选项，例如 `methods`、`components` 和 `directives`，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对，合并策略参考**data**。

### 全局混入

混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响**每一个**之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。

``` js
// 为自定义的选项 'myOption' 注入一个处理器。
Vue.mixin({
  created: function () {
    var myOption = this.$options.myOption
    if (myOption) {
      console.log(myOption)
    }
  }
})

new Vue({
  myOption: 'hello!'
})
// => "hello!"
```

